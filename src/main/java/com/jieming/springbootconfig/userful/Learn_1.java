package com.jieming.springbootconfig.userful;
/**
 *
 * 关于动态规划算法分析
 * */
public class Learn_1 {

    /*
    * 动态规划核心思想：
    * 1 拆分子问题
    * 2 记住过往
    * 3 减少重复计算
    * */

    /*
    * 动态规划截图套路：
    * 什么样的问题可以考虑使用动态规划解决呢？：
    *               如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划
    * 场景：
    *    1 求最长递增子序列
    *    2 最小编辑距离
    *    3 背包问题
    *    4 凑零钱问题
    *
    * */

    /*
    * 动态规划解题思路：
    * 1 穷举分析
    * 2 确定边界
    * 3 找出问题，确定最优子结构
    * 4 写出状态转移方程
    * */

    /**
     * 练习：求 nums = [10,9,2,5,3,7,101,18] 数组的最长递增子序列的长度
     *
     */

    /*
    * 按照动态规划的解题思路解题：
    * 1 穷举分析
    *   如果nums 只有1个元素10.则最长递增子序列是就是：10 ，最长子序列长度为1
    *   如果nums 只有2个元素10,9.则最长递增子序列是就是：10或 9 ，最长子序列长度为1
    *   如果nums 只有2个元素10,9，2.则最长递增子序列是就是：10或 9或2 ，最长子序列长度为1
    *   如果nums 只有2个元素10,9，2，5.则最长子序列是就是：2 ，5，最长子序列长度为2
    *   如果nums 只有2个元素10,9，2，5，3.则最长子序列是就是：2 、5或2、3，最长子序列长度为2
    *   如果nums 只有2个元素10,9，2，5，3，7.则最长子序列是就是：2 、5、7或2、3、7，最长子序列长度为3
    *   。。。。
    *
    * 2 确定边界
    *   只要数组不为null，肯定至少为1
    * 3 确定最优子结构
    *   当为num[i]时，最长递增子序列的长度为 num[i-1]的最长子序列长度 d[i-1]
    * 4 装状态转移方程：
    *  d[i-1]或d[i-1]+1
     * */
}
